문제
==
![1](https://user-images.githubusercontent.com/73854324/125051761-3fa3e800-e0de-11eb-8c8c-1cf1b9d5cb14.PNG)
![2](https://user-images.githubusercontent.com/73854324/125051767-40d51500-e0de-11eb-9fa6-8419cc1ccb7c.PNG)
<br><br>
==
처음에는 xor 연산을 사용했다.   
xor 연산의 결과는, 비트가 같으면 0 다르면 1 이 나온다.   
1의 개수가 2개 이하일 경우 정답처리를 했는데 시간초과 라는 결과를 받았다..   
![캡처](https://user-images.githubusercontent.com/73854324/125051939-6b26d280-e0de-11eb-9a28-a59ef917846c.PNG)   
   
그래서 비트를 직접 조작해보는 방법을 생각했는데, 규칙이 있었다.   
<br>
```
1. 짝수는 항상 비트가 0으로 끝나고, 홀수는 1로 끝난다.
2. 짝수 +1 은 항상 문제가 원하는 정답에 해당한다.
3. 홀수는 뒤에서부터 01 의 비트를 10 으로 변경해주면 정답에 해당한다.
```
<br>
짝수는 쉽다. 그냥 +1을 해줘서 비트를 변경해주면 된다. (코드 내 주석추리한 부분)   
substring 을 사용한 이유는, 쉽게 이해할 수 있도록(?) 한 것인데.. 마지막 한자리를 자른 후 1을 붙여준 것이다. (그냥 +1 더한거다)   
<br>
홀수의 경우는, "01"을 찾아줘야한다. 여기서 lastIndexOf 메서드를 사용했다.   
indexOf 메서드는 앞에서부터 문자열을 찾고, lastIndexOf 메서드는 뒤에서부터 문자열을 찾는다.   
하지만 7 같은 경우는 2진수로 변환하면 "111" 이라서 "01" 을 찾을 수 없다.   
이러한 경우에는 index 값이 "-1" 로 들어가는데,   
```
if(index==-1){
	sb.append("10"+binary.substring(2));
}
```
를 추가하기보다는 그냥 애초에 문자열 앞에 0을 더해줘서 무조건 01을 찾을 수 있도록 해주었다.   
"0" 만 붙여줘도 상관없는데 "00" 을 앞에 붙여준 이유는, "0111" 일 경우, substring(0,0) 이 되는데, 이러면 ""문자로 잘린다.   
그냥 개인적인 불치병(?) 같은 것이다.. (좌우를 항상 동일하게 맞춰줘야하는 습관 같은것..)   
<br><br>
마지막으로, StringBuilder 를 String 형식으로 변경 후, 다시 10진수로 변환해서 answer 배열에 넣어줬다.

