문제
==
![캡처](https://user-images.githubusercontent.com/73854324/121986955-7aae4680-cdd2-11eb-8205-fc54a1899454.PNG)
<br><br>
==
```
class Solution {
    int solution(int[][] land) {
        int index = -1;
        int max = 0;
        int answer = 0;
        
        for(int i=0;i<land.length;i++){
            max = 0;
            
            for(int j=0;j<land[i].length;j++){
                if(index == j) continue;
                if(max<land[i][j]){
                    max = land[i][j];
                    index = j;
                }
            }
            answer+=max;
        }
        return answer;
    }
}
```
처음 접했을 때 작성 한 코드이다.   
생각보다 쉽네 하고 풀었지만 바로 실패했다..   
index는 이전 행에서의 최대값 위치를 저장하는 변수인데, 이 값이 내가 원하는 값을 저장하지 못하는 것이 이유였다.   
뿐만 아니라, 그리디 한 방법이기 때문에 index 가 원하는 값을 저장하도록 했었어도 정답은 아니였다.
   
찾아보니 DP 문제라고 하더라.   
음.. DPS 는 아닌 것 같은데 DP는 뭐지?   
그 후 DP에 관해서 찾아보았다.   
대표적인 예시는 피보나치 수열이다. 찾아보니 죄다 이것만 나오기도 하고..   

먼저 나는 접근방식을 잘 못 생각했다.   
각 행들의 값에, 이전 값들의 최댓값들을 더해주면서 찾아야 한다.   
그렇지 않으면 위처럼 그리디 한 방식으로 되기 때문이다.   
   
잠깐 예를 들어보자면,   
```
[1,2,3]
[5,6,99]
```
극단적인 예시를 한번 들어보자면,   
그리디 한 방식으로는 3과 6을 선택할 수 밖에 없다.   
   
DP 방식으로 생각해보자   
2번째 행에서 5가 최대일 경우 1번째 행에서의 3이 선택, 5+3 = 8   
2번째 행에서 6가 최대일 경우 1번째 행에서의 3이 선택, 6+3 = 9   
2번째 행에서 99가 최대일 경우 1번째 행에서의 2이 선택, 99+2 = 101 이 된다.   
   
이제 코드를 보며 다시 한번 이해해보자.